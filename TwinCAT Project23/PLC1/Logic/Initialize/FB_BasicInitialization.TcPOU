<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_BasicInitialization" Id="{1f71eed9-1647-4f73-9cf0-1c68a7926b78}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_BasicInitialization
VAR_INPUT
	bExcute								: BOOL;
	nSizeOfMover					: INT;
	aLocationOfArea				: ARRAY[1..4,1..2] OF REAL;	
	ipMover								: ARRAY [0..Tc3_XPlanarStandard.Params_XPlanar.moverCount] OF I_XPlanarMover;//I_Mover;
	bReset								: BOOL;	
	
END_VAR
VAR_OUTPUT
	Busy									: BOOL;
	Done									: BOOL;
	Error									: BOOL;
	ErrorCode							: WSTRING;
	
	
	
END_VAR
VAR
	bFlagAuto						: BOOL;
	bFlagManual         		: BOOL;
	nState								: INT;
	bStart								: BOOL;
	nZoneColumn				: INT;
	nZoneRow						: INT;	
	aTable							: ARRAY[1..20]OF INT;
	aInitialPoint					: ARRAY[1..20,1..2] OF REAL;
	fZoneLengthX				: REAL;
	fZoneLengthY				: REAL;
	SortingState						:INT;	
	MovingState						:INT;	
	bDone 					: BOOL;
	fbMoverSortList				:ARRAY[1..10] OF FB_MoverList;	
	nCounterX							:ARRAY[1..20] OF INT;									//mover number in every zone
//	nTileRowCount								: INT :=3;
//	nTileColumnCount						: INT :=4;
//	MOVER_LENGTH							: REAL:=156;	
//	fTileLengthX									: LREAL :=240*nTileColumnCount;
//	fTileLengthY									: LREAL :=240*nTileRowCount;
END_VAR
VAR_IN_OUT
	aManualPos					: ARRAY [*,*] OF REAL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF bExcute = TRUE THEN
	IF nSizeOfMover <>115 AND nSizeOfMover <> 155 AND nSizeOfMover <> 235 THEN
		Error  := TRUE;
		ErrorCode := "Mover size is not correct";
	ELSE
		bStart := bExcute AND NOT Error ;
	END_IF	
END_IF

IF bStart THEN
	CASE nState OF
		
	0:
		IF M_CalculateArea(nSizeOfMover:=nSizeOfMover,aLocationOfArea:=aLocationOfArea,nZoneColumn=>nZoneColumn,nZoneRow=>nZoneRow,fZoneLengthX=>fZoneLengthX,fZoneLengthY=>fZoneLengthY) = TRUE THEN
				Busy := TRUE;
				Error  := FALSE;
				ErrorCode := "";
				nState := 10;
			ELSE
				Error  := TRUE;
				ErrorCode := "Area is not correct";			
				nState := 99;	
		END_IF 
		
	10:
		IF M_JudgePoint(aManualPos:=aManualPos) = TRUE THEN
				Busy := TRUE;
				Error  := FALSE;
				ErrorCode := "";
				nState := 20;
			ELSE
				Error  := TRUE;
				ErrorCode := "Point is not correct";			
				nState := 99;	
		END_IF				
	
	20:
		IF M_CreateTable(nSizeOfMover:=nSizeOfMover,nZoneColumn:=nZoneColumn,nZoneRow:=nZoneRow,aLocationOfArea:=aLocationOfArea,fZoneLengthY:=fZoneLengthY,aManualPos:=aManualPos,aTable=>aTable) = TRUE THEN
				Busy := TRUE;
				Error  := FALSE;
				ErrorCode := "";
				nState := 30;
			ELSE
				Error  := TRUE;
				ErrorCode := "Position is not correct";	
				nState := 99;				
		END_IF 	
	
	
	30:
				IF M_MoverSorting(nSizeOfMover:=nSizeOfMover,nZoneColumn:=nZoneColumn,nZoneRow:=nZoneRow,aTable:=aTable,fZoneLengthX:=fZoneLengthX,fZoneLengthY:=fZoneLengthY) = TRUE THEN
					Busy := TRUE;		
					Done := FALSE;		
					nState := 40;	
				END_IF
				
	40:
				IF M_MoveToInitialPos(aManualPos:=aManualPos) = TRUE THEN
//					Busy := FALSE;		
//					Done := TRUE;		
					nState := 100;	
				END_IF		

	END_CASE
END_IF

IF bReset THEN
	THIS^.FB_init(TRUE,TRUE);
END_IF
]]></ST>
    </Implementation>
    <Method Name="FB_init" Id="{7c228b7b-b903-4fde-9d80-68a6630799c3}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CalculateArea" Id="{98fe9f33-1328-41a1-9121-91693617d664}">
      <Declaration><![CDATA[METHOD M_CalculateArea : BOOL
VAR_INPUT
		nSizeOfMover					: INT;
		aLocationOfArea				: ARRAY[1..4,1..2] OF REAL;	
END_VAR
VAR_OUTPUT
	nZoneRow							: INT;
	nZoneColumn					: INT;
	fZoneLengthX					: REAL;
	fZoneLengthY					: REAL;
END_VAR
VAR_INST
	fRegionalArea					: REAL;	
END_VAR


]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF aLocationOfArea[1,1] >= 0 AND aLocationOfArea[1,2] >= 0 AND aLocationOfArea[2,1] >= 0 AND aLocationOfArea[2,2] >= 0 AND
	aLocationOfArea[3,1] >= 0 AND aLocationOfArea[3,2] >= 0 AND aLocationOfArea[4,1] >= 0 AND aLocationOfArea[4,2] >= 0 AND
	aLocationOfArea[2,1] > aLocationOfArea[1,1] AND aLocationOfArea[4,1] > aLocationOfArea[3,1] AND
	aLocationOfArea[2,2] > aLocationOfArea[4,2] AND aLocationOfArea[1,2] > aLocationOfArea[3,2] AND
	aLocationOfArea[2,2] = aLocationOfArea[1,2] AND aLocationOfArea[4,2] = aLocationOfArea[3,2] AND
	aLocationOfArea[1,1] = aLocationOfArea[3,1] AND aLocationOfArea[2,1] = aLocationOfArea[4,1] THEN
	fZoneLengthX := aLocationOfArea[2,1] - aLocationOfArea[1,1];
	fZoneLengthY := aLocationOfArea[2,2] - aLocationOfArea[4,2];
	fRegionalArea := fZoneLengthX*fZoneLengthY;
	IF nSizeOfMover*nSizeOfMover > fRegionalArea/4 THEN
		    M_CalculateArea :=FALSE;
		ELSE
			nZoneRow :=LREAL_TO_INT(FLOOR(fZoneLengthY/INT_TO_REAL(nSizeOfMover+5)));
			nZoneColumn :=LREAL_TO_INT(FLOOR(fZoneLengthX/INT_TO_REAL(nSizeOfMover+5)));			
	END_IF
END_IF

IF nZoneColumn > 0 AND nZoneRow >0 THEN
	M_CalculateArea := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CreateTable" Id="{d25f044f-3205-4c34-a0f1-e5689f938f8e}">
      <Declaration><![CDATA[METHOD M_CreateTable : BOOL
VAR_INPUT
		nSizeOfMover					: INT;
		aLocationOfArea				: ARRAY[1..4,1..2] OF REAL;	
		nZoneColumn					: INT;
		nZoneRow							: INT;	
		fZoneLengthY					: REAL;
END_VAR
VAR_OUTPUT
//	aMoverIndexInArea				: ARRAY[1..20] OF INT;
	aTable									: ARRAY[1..20] OF INT;
END_VAR
VAR_IN_OUT
	aManualPos							: ARRAY [*,*] OF REAL;

END_VAR

VAR
	i										: INT;
	nCounter						: INT;
	nCounter2						: INT;
	j										: INT;
	k										: INT;
    nAL1								: INT 		:= DINT_TO_INT(LOWER_BOUND(aManualPos, 1));						//row
    nAU1								: INT 		:= DINT_TO_INT(UPPER_BOUND(aManualPos, 1));
    nAL2								: INT 		:= DINT_TO_INT(LOWER_BOUND(aManualPos, 2));						//col
    nAU2								: INT 		:= DINT_TO_INT(UPPER_BOUND(aManualPos, 2));
	nRemainder					:INT;
	fdistance						: REAL;
	ftemp								: REAL;
	nArrayIsEmpty				: BOOL;
	aTemp							: ARRAY[1..20,1..2] OF REAL;
	aInitialPoint					: ARRAY [1..20,1..2] OF REAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR  i := 1 TO TO_INT(Tc3_XPlanarStandard.Params_XPlanar.moverCount) DO
	IF ipMover[i].std.P_ActPosition.x > aLocationOfArea[1,1] AND ipMover[i].std.P_ActPosition.y < aLocationOfArea[1,2] AND
		ipMover[i].std.P_ActPosition.x < aLocationOfArea[4,1] AND ipMover[i].std.P_ActPosition.y > aLocationOfArea[4,2] THEN
		nCounter := nCounter + 1;
//		j := j + 1;
//		aMoverIndexInArea[j] := i;
	END_IF
END_FOR

FOR i := 1 TO nAU1 DO
	FOR j := 1 TO nAU2 DO
		IF aManualPos[i,j] <> 0 THEN
			nArrayIsEmpty:= TRUE;	
		END_IF
	END_FOR
END_FOR


IF nAU1 =0 OR nAU2  = 0  OR nArrayIsEmpty = FALSE THEN
		IF nCounter <> 0 THEN																															// auto mode
			
		
			k := nCounter/nZoneRow;
			nRemainder := nCounter MOD nZoneRow;
			IF k >= 1 THEN
				FOR i:=1 TO nZoneRow DO
					aTable[i] := k;		
				END_FOR	
				FOR i:=1 TO nZoneRow DO
					IF nRemainder > 0 THEN
						aTable[i] := aTable[i] + 1;				
						nRemainder := nRemainder-1;
					END_IF
				END_FOR	

				ELSE
					FOR i:=1 TO nRemainder DO
						aTable[i] := 1;	
					END_FOR				
			END_IF
		
			M_CreateTable := TRUE;		
		
		END_IF

	ELSE																																							// manual mode
		IF nCounter <> 0 THEN//AND nCounter = nAU1 THEN	
   			FOR i:=1 TO nAU1 DO
				FOR j:=1 TO 2 DO
					aInitialPoint[i,j]:=aManualPos[i,j];				
				END_FOR
			END_FOR
   			FOR i:=1 TO nAU1 DO		
				FOR j:=1 TO nAU1 DO		
						fdistance:=SQRT((aLocationOfArea[1,1]-aInitialPoint[j,1])*(aLocationOfArea[1,1]-aInitialPoint[j,1]) + (aLocationOfArea[1,2]-aInitialPoint[j,2])*(aLocationOfArea[1,2]-aInitialPoint[j,2]));
						IF fdistance < ftemp THEN
							ftemp := fdistance;
							aTemp[j,1] := aInitialPoint[j,1];
							aTemp[j,2] := aInitialPoint[j,2];	
							aInitialPoint[j,1] := aInitialPoint[j+1,1];
							aInitialPoint[j,2] := aInitialPoint[j+1,2];	
							aInitialPoint[j+1,1] := aTemp[j,1];
							aInitialPoint[j+1,2] := aTemp[j,2];							
						END_IF
				END_FOR
			END_FOR
	
			FOR i := 1 TO nZoneRow DO
				FOR j := 1 TO 2 DO
					aManualPos[i,j]:=	aInitialPoint[i,j];			
				END_FOR
			END_FOR
		
			FOR i := 1 TO nZoneRow DO
				FOR j := 1 TO nCounter DO
					IF aInitialPoint[j,2] <=  fZoneLengthY*(nZoneRow+1-i)/nZoneRow AND aInitialPoint[j,2] >  fZoneLengthY*(nZoneRow-i)/nZoneRow THEN
						aTable[i] := aTable[i] + 1;		
					END_IF					
				END_FOR
			END_FOR
		
			M_CreateTable := TRUE;			
		END_IF
END_IF


]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_JudgePoint" Id="{9a560356-5b88-41b5-bf21-eec8748d3755}">
      <Declaration><![CDATA[METHOD M_JudgePoint : BOOL
VAR_INPUT
END_VAR
VAR_IN_OUT
	aManualPos							: ARRAY [*,*] OF REAL;
END_VAR

VAR
	nAL1								: INT 		:= DINT_TO_INT(LOWER_BOUND(aManualPos, 1));						//row
    nAU1								: INT 		:= DINT_TO_INT(UPPER_BOUND(aManualPos, 1));
    nAL2								: INT 		:= DINT_TO_INT(LOWER_BOUND(aManualPos, 2));						//col
    nAU2								: INT 		:= DINT_TO_INT(UPPER_BOUND(aManualPos, 2));
	i,j,k									: INT;
	fDis									: REAL;
	bJudge1							: BOOL;
	bJudge2							: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Judge whether  the aManualPos points is appropriate and whether the boundary will be touched
bJudge1 := TRUE;
bJudge2 := TRUE;
FOR i := 1 TO nAU1-1 DO
		bJudge1 := bJudge1 AND (aManualPos[i,1] - TO_REAL(nSizeOfMover)/2.0 >=1) AND (aManualPos[i,2] - TO_REAL(nSizeOfMover)/2.0 >=1 );
		FOR j := i TO nAU1-1 DO
			fDis := SQRT((aManualPos[j,1] -  aManualPos[j+1,1])*(aManualPos[j,1] -  aManualPos[j+1,1]) + (aManualPos[j,2] -  aManualPos[j+1,2])*(aManualPos[j,2] -  aManualPos[j+1,2]));
			bJudge2 := bJudge2 AND (fDis > nSizeOfMover + 7 );
		END_FOR
END_FOR

IF bJudge1 AND bJudge2 THEN
	M_JudgePoint := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MoverSorting" Id="{509dfbff-314a-48f9-824f-327c3ccae1fb}">
      <Declaration><![CDATA[METHOD M_MoverSorting : BOOL
VAR_INPUT
	nSizeOfMover				: INT;
	nZoneColumn				: INT;
	nZoneRow						: INT;	
	aTable							: ARRAY[1..20]OF INT;
	fZoneLengthX					: REAL;
	fZoneLengthY					: REAL;
END_VAR
VAR_INST
	i,j,k							:INT;
	InitList					:FB_MoverList;
	nSorting					: ARRAY [1..20] OF INT;
	
	fTileLengthX									: LREAL ;
	fTileLengthY									: LREAL ;
	
	nMoverIndex					:INT ;
	Xpoint								:LREAL;
	Ypoint								:LREAL;
	nZoneCounter					:INT;																	// zone number
	nCounterMem					:ARRAY[1..10] OF INT;									//mover number difference expected
	nMoverIistInZone			: ARRAY[0..Tc3_XPlanarStandard.Params_XPlanar.moverCount] OF INT;

	bGet									: BOOL;
	nGet									:INT;
	bGive									: BOOL;
	nGive									:INT;	
	bFirstGive							: BOOL;
	bFirstGet							: BOOL;
	nMAX									:INT;
	nMAXTemp						: INT;
	nPos									:INT;
	fLengthGive						:LREAL;
	fLengthY							:LREAL;
	fLengthGet						:LREAL;
	Pos										:PositionXYC;

	InitVelo							:LREAL;
	InitAcc,InitDec				:LREAL;
	InitJerk							:LREAL;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[	InitVelo:=SetInitVelo;
	InitAcc:=SetInitAccDec;
	InitDec:=SetInitAccDec;
	InitJerk:=SetInitJerk;

IF bReset THEN
	SortingState := 0;
	nMoverIndex :=0;
	nZoneCounter:=0;
END_IF

CASE SortingState OF
	0:
		FOR i:=1 TO TO_INT(Tc3_XPlanarStandard.Params_XPlanar.moverCount) DO 
			InitList.M_AddToList(i);
		END_FOR
		SortingState:=1;
	1:
		fTileLengthY := TO_LREAL(fZoneLengthY);
		fTileLengthX := TO_LREAL(fZoneLengthX);		
		FOR i := 1 TO 20 DO
			nSorting[i] := aTable[i];
		END_FOR
		SortingState:=10;
	10:
		IF InitList.List[0]>0 THEN 
			nMoverIndex:=0;
			memset(ADR(nCounterX),0,SIZEOF(nCounterX));
			k:=1;
			SortingState:=20;
		END_IF
		
		
///////////////////////************Movers within each zone move to the top of the zone in turn*************/////////////////////////////
	20:
		IF nMoverIndex<Tc3_XPlanarStandard.Params_XPlanar.moverCount THEN 
			nMoverIndex:=nMoverIndex+1;
			SortingState:=30;
		ELSE
			SortingState:=60;
		END_IF
	30:
		Xpoint:=ipMover[nMoverIndex].std.P_SetPosition.x;
		Ypoint:=ipMover[nMoverIndex].std.P_SetPosition.y;
		IF Ypoint <= fTileLengthY*(nZoneRow-nZoneCounter)/nZoneRow-TO_REAL(nSizeOfMover)/2.0
			AND Ypoint >= fTileLengthY*(nZoneRow-nZoneCounter-1)/nZoneRow-TO_REAL(nSizeOfMover)/2.0 THEN
//			AND F_CheckMoverCanMove(nMoverIndex,Xpoint,Ypoint,ipMover) THEN
			SortingState:=40;			
		ELSE
			SortingState:=20;
		END_IF	

	40:
		Pos.SetValuesXY(ipMover[nMoverIndex].std.P_SetPosition.x,fTileLengthY*(nZoneRow-nZoneCounter)/nZoneRow-(nSizeOfMover+1)/2-1);
		ipMover[nMoverIndex].std.MoveToPosition('',
																	pos,
																	InitVelo,
																	InitAcc,
																	InitAcc,
																	InitJerk);
		nCounterX[nZoneCounter+1]:=nCounterX[nZoneCounter+1]+1;
		nMoverIistInZone[k]:=nMoverIndex;
		k:=k+1;
		SortingState:=50;
	
	50:
		IF 	ipMover[nMoverIndex].std.P_MoveToPosition.Done THEN 
			SortingState:=20;	
		END_IF


///////////////////////************sorting movers in every zone*************/////////////////////////////				
	60:
		fbMoverSortList[nZoneCounter+1]:=M_SortingInZone(nCounterX[nZoneCounter+1],nMoverIistInZone,ipMover);
		FOR i := 1 TO nCounterX[nZoneCounter+1] DO
				fbMoverSortList[nZoneCounter+1].M_AddToList(fbMoverSortList[nZoneCounter+1].List[i]);
		END_FOR
		k:=1;
		nZoneCounter:=nZoneCounter+1;
		IF nZoneRow - nZoneCounter > 0 THEN
			nMoverIndex:=0;			
			SortingState:=20;
			ELSE
			nZoneCounter:=0;
			SortingState:=110;				
		END_IF


///////////////////////************Movers move to left of the zone in turn*************/////////////////////////////				
	110:
		IF InitList.List[0]>0 THEN 
			SortingState:=120;
		END_IF
		
	120:
		nZoneCounter:=nZoneCounter+1;
		IF nZoneRow - nZoneCounter >= 0 THEN	
			SortingState:=130;
			ELSE
			SortingState:=200;	
		END_IF		

	130:
		IF nCounterX[nZoneCounter] = 0 THEN
					SortingState:=120;				
			ELSE
				FOR i:=1 TO nCounterX[nZoneCounter] DO
					Pos.SetValuesXY((i-1)*fTileLengthX/INT_TO_LREAL(nZoneColumn)+(fTileLengthX/INT_TO_LREAL(nZoneColumn)+1)/2+2,ipMover[fbMoverSortList[nZoneCounter].List[i]].std.P_SetPosition.y);
					ipMover[fbMoverSortList[nZoneCounter].List[i]].std.MoveToPosition('',
																				pos,
																				InitVelo,
																				InitAcc,
																				InitAcc,
																				InitJerk);
					SortingState:=150;		
				END_FOR				
		END_IF


	150:
		bDone:=TRUE;
		FOR i:=1 TO nCounterX[nZoneCounter] DO
			bDone := bDone AND ipMover[fbMoverSortList[nZoneCounter].List[i]].std.P_MoveToPosition.Done;
		END_FOR
		IF bDone THEN
			SortingState:=120;
		END_IF
		

///////////////////////************Movers move to table point in turn*************/////////////////////////////		
	200:
//		FOR i := 1 TO  nZoneRow DO
//			IF nCounterX[i]- nSorting[i] > 0 THEN
//				bGive:=TRUE;
//				nGive:=i;
//			ELSIF	nCounterX[i]- nSorting[i] < 0 THEN
//				bGet:=TRUE;		
//				nGet:=i;
//			ELSE
//				;
//			END_IF
//			IF bGive AND bGet THEN
//				bGive:=FALSE;
//				bGet:=FALSE;
//				SortingState:=210;
//				EXIT;
//			END_IF
//		END_FOR
		FOR i := 1 TO  nZoneRow DO
			IF nCounterX[i]- nSorting[i] > 0 THEN
				bGive:=TRUE;
				bFirstGive := TRUE;
				nGive:=i;
				EXIT;
			ELSIF	nCounterX[i]- nSorting[i] < 0 THEN
				bGet:=TRUE;	
				bFirstGet := TRUE;	
				nGet:=i;
				EXIT;
			ELSE
				;
			END_IF
		END_FOR

		FOR j := i TO  nZoneRow DO
			IF bFirstGive AND nCounterX[j]- nSorting[j] < 0 THEN
				bGet:=TRUE;		
				nGet:=j;		
			END_IF		
			IF bFirstGet AND nCounterX[j]- nSorting[j] > 0 THEN
				bGive:=TRUE;
				nGive:=j;		
			END_IF		
		END_FOR
		
		IF bGive AND bGet THEN
			bGive:=FALSE;
			bGet:=FALSE;
			SortingState:=210;
		END_IF
		
		IF MEMCMP(ADR(nCounterX) , ADR(nSorting),SIZEOF(nSorting)) = 0 THEN	
				SortingState:=500;					
		END_IF		
		
	210:
		IF nGive > nGet THEN
				nMAXTemp := nCounterX[nGet];
				nMAX := nGet; 				
				FOR i := nGet TO nGive BY 1 DO
					IF i + 1 <= nGive THEN
						IF nMAXTemp <= nCounterX[i+1] THEN
							nMAXTemp := nCounterX[i+1];
							nMAX := i + 1;
//							ELSE
//							nMAX := i; 	
						END_IF	
					END_IF
				END_FOR	
//		nPos:=nCounterX[nMAX] - nCounterX[nGet]+1;
//		IF nMAX - nGet = 0 THEN
//			nPos := 0;
//		END_IF				
			ELSE
					nMAXTemp := nCounterX[nGive];
					nMAX := nGive; 
				FOR i := nGive TO nGet BY 1 DO
					IF i + 1 <= nGet THEN
						IF nMAXTemp <= nCounterX[i+1] THEN
							nMAXTemp := nCounterX[i+1];
							nMAX := i + 1;
//							ELSE
//							nMAX := i; 								
						END_IF	
					END_IF
				END_FOR	

						
		END_IF
		
		nPos:=nCounterX[nMAX] - nCounterX[nGive]+1;
		IF nMAX = nGive AND NOT (nCounterX[nGive] = nCounterX[nGet]) THEN		
				nPos := 0;			
		END_IF
//		nPos:=nCounterX[nMAX] - nCounterX[nGive]+1;
//		IF nCounterX[nMAX] - nCounterX[nGive] = 0 THEN
//			nPos := 0;
//		END_IF
		nMoverIndex:=fbMoverSortList[nGive].List[nCounterX[nGive]];
		fLengthGive:=ipMover[nMoverIndex].std.P_SetPosition.x+nPos*fTileLengthX/INT_TO_LREAL(nZoneColumn)+7;
		fLengthY:=ipMover[nMoverIndex].std.P_SetPosition.y;
		Pos.SetValuesXY(fLengthGive,fLengthY);
		SortingState:=220;		
	
	220:
		ipMover[nMoverIndex].std.MoveToPosition('',
																	Pos,
																	InitVelo,
																	InitAcc,
																	InitAcc,
																	InitJerk);	

		SortingState:=221;
		
	221:
		IF 	ipMover[nMoverIndex].std.P_MoveToPosition.Done THEN 
			SortingState:=230;	
		END_IF
		
	230:
		fLengthY:=ipMover[nMoverIndex].std.P_SetPosition.y+INT_TO_LREAL(nGive-nGet)*fTileLengthY/INT_TO_LREAL(nZoneRow);					
		Pos.SetValuesXY(ipMover[nMoverIndex].std.P_SetPosition.x,fLengthY);
//		Pos.SetValuesXY(fLengthGive,fLengthY);		
		SortingState:=240;		
		
		
	240:
		ipMover[nMoverIndex].std.MoveToPosition('',
																	Pos,
																	InitVelo,
																	InitAcc,
																	InitAcc,
																	InitJerk);	
		SortingState:=241;
		
	241:
		IF 	ipMover[nMoverIndex].std.P_MoveToPosition.Done THEN 
			SortingState:=250;	
		END_IF

	250:
		nPos:=ABS(nCounterX[nMAX] - nCounterX[nGet]);	
	
		IF nMAX = nGive THEN
			nPos:=ABS(nCounterX[nMAX] - nCounterX[nGet])-1;			
		END_IF

//		IF nGet > nGive AND nMAX = nGive THEN		
//			nPos:=ABS(nCounterX[nMAX] - nCounterX[nGet]);		
//		END_IF		
		
		IF nMAX = nGet  THEN
			nPos:=0;
		END_IF		
		fLengthGet:=ipMover[nMoverIndex].std.P_SetPosition.x-INT_TO_LREAL(nPos)*fTileLengthX/INT_TO_LREAL(nZoneColumn)-7;
		fLengthY:=ipMover[nMoverIndex].std.P_SetPosition.y;
		Pos.SetValuesXY(fLengthGet,fLengthY);
		SortingState:=260;		
		
	260:
		ipMover[nMoverIndex].std.MoveToPosition('',
																	Pos,
																	InitVelo,
																	InitAcc,
																	InitAcc,
																	InitJerk);			
				nCounterX[nGet]:=nCounterX[nGet]+1;
				nCounterX[nGive]:=nCounterX[nGive]-1;

//				fbMoverSortList[nGet].List[nCounterX[nGet]]:= nMoverIndex;
				nMoverIndex:=fbMoverSortList[nGive].M_RemoveLastFromList();
				fbMoverSortList[nGet].M_AddToList(nMoverIndex);	
				SortingState:=261;		

	261:
		IF 	ipMover[nMoverIndex].std.P_MoveToPosition.Done THEN 
			nGive := 0;
			nGet := 0;
			SortingState:=200;	
		END_IF	


	500:			
		M_MoverSorting:=TRUE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MoveToInitialPos" Id="{998bd592-72a6-4e2d-ac3c-24c7b6654b7b}">
      <Declaration><![CDATA[METHOD M_MoveToInitialPos : BOOL
VAR_INPUT
	
END_VAR
VAR_IN_OUT
	aManualPos							: ARRAY [*,*] OF REAL;
END_VAR
VAR_INST
	i,j,k							:INT;
	
	InitVelo							:LREAL;
	InitAcc,InitDec				:LREAL;
	InitJerk							:LREAL;
	
	PosArr								:PositionXYC;
	IsAllArrived					: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[	InitVelo:=SetInitVelo;
	InitAcc:=SetInitAccDec;
	InitDec:=SetInitAccDec;
	InitJerk:=SetInitJerk;

CASE MovingState OF
	0:
		i := i + 1;
		IF nCounterX[i]<> 0 THEN			
			k := k + nCounterX[i];
			FOR j := 1 TO nCounterX[i] DO
				PosArr.SetValuesXY(aManualPos[k+1-j,1],aManualPos[k+1-j,2]);	
				ipMover[fbMoverSortList[i].List[nCounterX[i]+1-j]].std.MoveToPosition('',
								PosArr,
								InitVelo,
								InitAcc,
								InitAcc,
								InitJerk);					
			END_FOR
		END_IF
		MovingState:=10;
	
	10:
		IF i > nZoneRow THEN
				MovingState:=20;	
			ELSE
				MovingState:=0;	
		END_IF	
		
	20:
		k := 0;
		i := 0;		
		IsAllArrived:=TRUE;
			FOR j:=1 TO TO_INT(Tc3_XPlanarStandard.Params_XPlanar.moverCount) DO 	
				IsAllArrived:=IsAllArrived AND ipMover[j].std.P_MoveToPosition.Done;
			END_FOR	

		IF IsAllArrived THEN 
				MovingState:=50;								
		END_IF


	50:
		M_MoveToInitialPos := TRUE;
		
	
	
	
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_SortingInZone" Id="{a16f304e-ef8d-4ef2-b446-c1de021267c3}">
      <Declaration><![CDATA[METHOD M_SortingInZone : FB_MoverList
VAR_INPUT
	nNumber													: INT;
	nMoverList													: ARRAY[0..MAX_MOVERS] OF INT;
	ipMover														: ARRAY [0..MAX_MOVERS] OF I_XPlanarMover;		
END_VAR
VAR
	MoverList													: ARRAY[0..MAX_MOVERS] OF INT;
	MoverListMem												: ARRAY[0..MAX_MOVERS] OF INT;
	IdMem															: INT;
	i,j,K,L,M,N														: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MEMSET(ADR(MoverList),0,SIZEOF(MoverList));
MEMCPY(ADR(MoverList),ADR(nMoverList),SIZEOF(nMoverList));
//FOR  M:=1 TO nNumber DO 
//		MoverList[0]										:=MoverList[0]+1;
//		MoverList[MoverList[0]]											:=M;
//END_FOR


FOR i:=1 TO nNumber-1 DO 
	FOR j := 1 TO nNumber-i DO
		IF ipMover[MoverList[j]].std.P_SetPosition.x>ipMover[MoverList[j+1]].std.P_SetPosition.x THEN 
			IdMem							:=MoverList[j];
			MoverList[j]					:=MoverList[j+1];
			MoverList[j+1]				:=IdMem;
		END_IF
	END_FOR
END_FOR	




//IF NOT EnableBackwards THEN 
	MoverListMem[0]							:=MoverList[0];
	FOR L:=1 TO nNumber  DO 
		MoverListMem[L]						:=MoverList[l];
	END_FOR
//ELSE
//	MEMCPY(ADR(MoverListMem[1]),ADR(MoverList[MAX_MOVERS_NUMBER- MoverList[0] +1]),SIZEOF(MoverListMem[1])*MoverList[0]);
//	MoverListMem[0]							:=MoverList[0];
//END_IF

M_SortingInZone.M_CopyList(MoverListMem);]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_BasicInitialization">
      <LineId Id="9" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="122" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="140" Count="1" />
      <LineId Id="127" Count="3" />
      <LineId Id="152" Count="0" />
      <LineId Id="149" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="150" Count="0" />
      <LineId Id="189" Count="0" />
      <LineId Id="142" Count="0" />
      <LineId Id="346" Count="0" />
      <LineId Id="334" Count="0" />
      <LineId Id="337" Count="8" />
      <LineId Id="336" Count="0" />
      <LineId Id="335" Count="0" />
      <LineId Id="143" Count="0" />
      <LineId Id="153" Count="7" />
      <LineId Id="190" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="192" Count="2" />
      <LineId Id="131" Count="2" />
      <LineId Id="284" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="285" Count="1" />
      <LineId Id="288" Count="3" />
      <LineId Id="287" Count="0" />
      <LineId Id="138" Count="0" />
      <LineId Id="123" Count="1" />
      <LineId Id="239" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="240" Count="1" />
      <LineId Id="106" Count="0" />
    </LineIds>
    <LineIds Name="FB_BasicInitialization.FB_init">
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_BasicInitialization.M_CalculateArea">
      <LineId Id="71" Count="18" />
      <LineId Id="47" Count="0" />
    </LineIds>
    <LineIds Name="FB_BasicInitialization.M_CreateTable">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="230" Count="17" />
      <LineId Id="249" Count="10" />
      <LineId Id="261" Count="28" />
      <LineId Id="336" Count="1" />
      <LineId Id="340" Count="1" />
      <LineId Id="335" Count="0" />
      <LineId Id="334" Count="0" />
      <LineId Id="290" Count="3" />
      <LineId Id="295" Count="5" />
      <LineId Id="37" Count="0" />
      <LineId Id="32" Count="1" />
      <LineId Id="28" Count="0" />
    </LineIds>
    <LineIds Name="FB_BasicInitialization.M_JudgePoint">
      <LineId Id="5" Count="0" />
      <LineId Id="56" Count="1" />
      <LineId Id="12" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="35" Count="1" />
    </LineIds>
    <LineIds Name="FB_BasicInitialization.M_MoverSorting">
      <LineId Id="787" Count="2" />
      <LineId Id="784" Count="1" />
      <LineId Id="1195" Count="1" />
      <LineId Id="1199" Count="1" />
      <LineId Id="786" Count="0" />
      <LineId Id="1197" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="803" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="1239" Count="1" />
      <LineId Id="1247" Count="1" />
      <LineId Id="1241" Count="2" />
      <LineId Id="19" Count="1" />
      <LineId Id="24" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="954" Count="0" />
      <LineId Id="1139" Count="0" />
      <LineId Id="25" Count="1" />
      <LineId Id="1252" Count="0" />
      <LineId Id="1259" Count="0" />
      <LineId Id="1253" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="63" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="843" Count="1" />
      <LineId Id="838" Count="0" />
      <LineId Id="881" Count="0" />
      <LineId Id="845" Count="0" />
      <LineId Id="839" Count="0" />
      <LineId Id="841" Count="1" />
      <LineId Id="840" Count="0" />
      <LineId Id="48" Count="1" />
      <LineId Id="52" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="53" Count="4" />
      <LineId Id="1018" Count="0" />
      <LineId Id="946" Count="0" />
      <LineId Id="1140" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="846" Count="0" />
      <LineId Id="59" Count="3" />
      <LineId Id="1254" Count="1" />
      <LineId Id="847" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="1134" Count="0" />
      <LineId Id="1496" Count="1" />
      <LineId Id="1495" Count="0" />
      <LineId Id="1141" Count="0" />
      <LineId Id="883" Count="0" />
      <LineId Id="1136" Count="0" />
      <LineId Id="889" Count="0" />
      <LineId Id="1137" Count="0" />
      <LineId Id="891" Count="0" />
      <LineId Id="885" Count="0" />
      <LineId Id="888" Count="0" />
      <LineId Id="886" Count="0" />
      <LineId Id="1256" Count="1" />
      <LineId Id="944" Count="0" />
      <LineId Id="939" Count="1" />
      <LineId Id="943" Count="0" />
      <LineId Id="892" Count="0" />
      <LineId Id="945" Count="0" />
      <LineId Id="893" Count="0" />
      <LineId Id="1142" Count="1" />
      <LineId Id="1145" Count="0" />
      <LineId Id="899" Count="0" />
      <LineId Id="1146" Count="1" />
      <LineId Id="935" Count="0" />
      <LineId Id="900" Count="0" />
      <LineId Id="1163" Count="1" />
      <LineId Id="1166" Count="0" />
      <LineId Id="1168" Count="8" />
      <LineId Id="1167" Count="0" />
      <LineId Id="1165" Count="0" />
      <LineId Id="1149" Count="0" />
      <LineId Id="920" Count="1" />
      <LineId Id="1157" Count="2" />
      <LineId Id="924" Count="0" />
      <LineId Id="1160" Count="2" />
      <LineId Id="1258" Count="0" />
      <LineId Id="925" Count="0" />
      <LineId Id="140" Count="0" />
      <LineId Id="176" Count="0" />
      <LineId Id="195" Count="0" />
      <LineId Id="998" Count="0" />
      <LineId Id="1007" Count="0" />
      <LineId Id="1024" Count="0" />
      <LineId Id="1001" Count="0" />
      <LineId Id="1013" Count="0" />
      <LineId Id="1027" Count="0" />
      <LineId Id="1003" Count="1" />
      <LineId Id="1000" Count="0" />
      <LineId Id="1014" Count="1" />
      <LineId Id="1017" Count="0" />
      <LineId Id="1019" Count="0" />
      <LineId Id="1177" Count="0" />
      <LineId Id="1016" Count="0" />
      <LineId Id="951" Count="0" />
      <LineId Id="1845" Count="2" />
      <LineId Id="1901" Count="0" />
      <LineId Id="1848" Count="0" />
      <LineId Id="1861" Count="0" />
      <LineId Id="1849" Count="1" />
      <LineId Id="1903" Count="0" />
      <LineId Id="1851" Count="0" />
      <LineId Id="1862" Count="0" />
      <LineId Id="1852" Count="2" />
      <LineId Id="1844" Count="0" />
      <LineId Id="1871" Count="0" />
      <LineId Id="1863" Count="0" />
      <LineId Id="1888" Count="0" />
      <LineId Id="1891" Count="0" />
      <LineId Id="1889" Count="0" />
      <LineId Id="1904" Count="0" />
      <LineId Id="1893" Count="0" />
      <LineId Id="1896" Count="0" />
      <LineId Id="1895" Count="0" />
      <LineId Id="1892" Count="0" />
      <LineId Id="1874" Count="0" />
      <LineId Id="1910" Count="0" />
      <LineId Id="1906" Count="3" />
      <LineId Id="1905" Count="0" />
      <LineId Id="1870" Count="0" />
      <LineId Id="1076" Count="1" />
      <LineId Id="1075" Count="0" />
      <LineId Id="948" Count="0" />
      <LineId Id="196" Count="0" />
      <LineId Id="1178" Count="0" />
      <LineId Id="1359" Count="0" />
      <LineId Id="1690" Count="0" />
      <LineId Id="1303" Count="0" />
      <LineId Id="1592" Count="3" />
      <LineId Id="1600" Count="0" />
      <LineId Id="1599" Count="0" />
      <LineId Id="1596" Count="0" />
      <LineId Id="1185" Count="0" />
      <LineId Id="1179" Count="0" />
      <LineId Id="1697" Count="2" />
      <LineId Id="1691" Count="0" />
      <LineId Id="1186" Count="0" />
      <LineId Id="1364" Count="0" />
      <LineId Id="1689" Count="0" />
      <LineId Id="1188" Count="0" />
      <LineId Id="1586" Count="0" />
      <LineId Id="1589" Count="2" />
      <LineId Id="1597" Count="1" />
      <LineId Id="1587" Count="1" />
      <LineId Id="1187" Count="0" />
      <LineId Id="1693" Count="0" />
      <LineId Id="1692" Count="0" />
      <LineId Id="1180" Count="0" />
      <LineId Id="1703" Count="0" />
      <LineId Id="1700" Count="0" />
      <LineId Id="1706" Count="0" />
      <LineId Id="1702" Count="0" />
      <LineId Id="1707" Count="0" />
      <LineId Id="1034" Count="0" />
      <LineId Id="1642" Count="2" />
      <LineId Id="1040" Count="0" />
      <LineId Id="1021" Count="0" />
      <LineId Id="1020" Count="0" />
      <LineId Id="1022" Count="1" />
      <LineId Id="1078" Count="0" />
      <LineId Id="200" Count="0" />
      <LineId Id="203" Count="4" />
      <LineId Id="201" Count="0" />
      <LineId Id="1097" Count="0" />
      <LineId Id="212" Count="0" />
      <LineId Id="1079" Count="1" />
      <LineId Id="1082" Count="1" />
      <LineId Id="1081" Count="0" />
      <LineId Id="1041" Count="0" />
      <LineId Id="213" Count="0" />
      <LineId Id="1308" Count="0" />
      <LineId Id="222" Count="0" />
      <LineId Id="1042" Count="3" />
      <LineId Id="1047" Count="6" />
      <LineId Id="242" Count="0" />
      <LineId Id="1084" Count="0" />
      <LineId Id="1086" Count="2" />
      <LineId Id="1085" Count="0" />
      <LineId Id="1055" Count="1" />
      <LineId Id="1801" Count="1" />
      <LineId Id="1798" Count="2" />
      <LineId Id="1060" Count="0" />
      <LineId Id="1755" Count="1" />
      <LineId Id="1753" Count="1" />
      <LineId Id="1646" Count="0" />
      <LineId Id="1705" Count="0" />
      <LineId Id="1645" Count="0" />
      <LineId Id="1058" Count="1" />
      <LineId Id="1057" Count="0" />
      <LineId Id="1062" Count="2" />
      <LineId Id="1068" Count="5" />
      <LineId Id="1066" Count="0" />
      <LineId Id="1540" Count="0" />
      <LineId Id="1544" Count="0" />
      <LineId Id="1193" Count="1" />
      <LineId Id="1498" Count="0" />
      <LineId Id="1054" Count="0" />
      <LineId Id="1089" Count="0" />
      <LineId Id="1074" Count="0" />
      <LineId Id="1092" Count="0" />
      <LineId Id="1897" Count="1" />
      <LineId Id="1093" Count="0" />
      <LineId Id="1090" Count="0" />
      <LineId Id="1366" Count="0" />
      <LineId Id="1095" Count="0" />
      <LineId Id="1094" Count="0" />
      <LineId Id="1096" Count="0" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="FB_BasicInitialization.M_MoveToInitialPos">
      <LineId Id="231" Count="2" />
      <LineId Id="229" Count="1" />
      <LineId Id="93" Count="1" />
      <LineId Id="276" Count="0" />
      <LineId Id="297" Count="0" />
      <LineId Id="316" Count="0" />
      <LineId Id="306" Count="0" />
      <LineId Id="309" Count="5" />
      <LineId Id="307" Count="1" />
      <LineId Id="299" Count="0" />
      <LineId Id="287" Count="0" />
      <LineId Id="188" Count="0" />
      <LineId Id="320" Count="0" />
      <LineId Id="322" Count="0" />
      <LineId Id="324" Count="2" />
      <LineId Id="323" Count="0" />
      <LineId Id="321" Count="0" />
      <LineId Id="172" Count="0" />
      <LineId Id="327" Count="1" />
      <LineId Id="205" Count="0" />
      <LineId Id="211" Count="0" />
      <LineId Id="218" Count="1" />
      <LineId Id="207" Count="0" />
      <LineId Id="191" Count="0" />
      <LineId Id="198" Count="0" />
      <LineId Id="195" Count="0" />
      <LineId Id="179" Count="0" />
      <LineId Id="202" Count="0" />
      <LineId Id="201" Count="0" />
      <LineId Id="203" Count="0" />
      <LineId Id="200" Count="0" />
      <LineId Id="96" Count="2" />
      <LineId Id="95" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_BasicInitialization.M_SortingInZone">
      <LineId Id="16" Count="8" />
      <LineId Id="57" Count="0" />
      <LineId Id="25" Count="4" />
      <LineId Id="58" Count="0" />
      <LineId Id="30" Count="14" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>